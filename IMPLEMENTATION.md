# AST-based C Code Minifier - Implementation Details

## 架构设计 (Architecture)

### 核心组件

1. **CMinifier类**: 主要的最小化器类
   - 管理AST解析
   - 跟踪作用域
   - 执行代码转换

2. **Scope类**: 作用域管理
   - 维护变量名映射
   - 生成短变量名
   - 处理受保护的作用域（struct/union/enum）

### 项目结构

```
cminify/
├── minify.py          # 主程序
├── run_tests.py       # 测试运行器
├── tests/             # 测试用例目录
│   ├── 01_basic.c
│   ├── 02_strings.c
│   └── ...
└── README.md          # 本文件
```

### 处理流程

```
源代码 → tree-sitter解析 → AST
                              ↓
                         遍历AST识别:
                         - 注释节点
                         - 标识符节点
                         - 作用域边界
                              ↓
                         记录修改:
                         - 删除列表
                         - 替换映射
                              ↓
                         重构代码
                              ↓
                         空白压缩
                              ↓
                         最小化代码
```

## 关键算法

### 1. 作用域管理

使用作用域栈来跟踪当前的变量作用域：

```python
scopes = [Scope()]  # 全局作用域
current_scope_idx = 0

# 进入新作用域
if node.type == 'compound_statement':
    scopes.append(Scope())
    current_scope_idx += 1
    
# 退出作用域
scopes.pop()
current_scope_idx -= 1
```

### 2. 变量识别

通过AST节点类型和父节点关系判断标识符的角色：

- **声明检测**: 检查父节点是否为 `init_declarator`, `parameter_declaration`, `field_declaration`
- **成员访问检测**: 检查父节点是否为 `field_expression`
- **静态全局检测**: 检查是否在全局作用域且有 `static` 修饰符

### 3. 变量重命名策略

1. **局部变量**: 在当前函数作用域内重命名
2. **函数参数**: 在函数定义的作用域内重命名
3. **静态全局变量**: 在全局作用域（索引0）重命名
4. **成员变量**: 不重命名（在受保护的作用域中）

### 4. 短名称生成

使用base-52编码生成短名称：

```
0 → a
1 → b
...
25 → z
26 → A
...
51 → Z
52 → aa
53 → ab
...
```

这样可以支持大量变量而不会冲突。

## 与正则表达式方法的对比

| 特性 | 正则表达式方法 | AST方法 |
|------|---------------|---------|
| 准确性 | 容易误判 | 准确理解语法 |
| 作用域处理 | 需要复杂的状态机 | 天然支持 |
| 成员访问 | 需要特殊规则 | 直接从AST识别 |
| 预处理指令 | 需要特殊处理 | AST自动区分 |
| 字符串/注释 | 需要复杂的转义处理 | AST自动区分 |
| 可维护性 | 难以扩展 | 易于添加新功能 |
| 性能 | 较快 | 稍慢（但可接受） |

## 已知限制

1. **宏展开**: 不处理宏展开，保持原样
2. **类型推断**: 不进行类型分析，仅基于语法结构
3. **跨文件引用**: 仅处理单个文件，不分析跨文件的符号引用
4. **函数指针**: 函数名不重命名，即使是静态函数

## 未来改进方向

1. **更激进的优化**:
   - 重命名静态函数
   - 内联简单函数
   - 常量折叠

2. **更好的空白处理**:
   - 完全移除不必要的换行
   - 更智能的空格压缩

3. **多文件支持**:
   - 分析整个项目的符号表
   - 跨文件的安全重命名

4. **配置选项**:
   - 可配置的重命名策略
   - 可配置的保留符号列表
   - 输出格式选项

## 测试覆盖

当前测试套件覆盖：

- ✅ 基础功能（注释、空白、简单重命名）
- ✅ 字符串和字符常量处理
- ✅ 预处理指令
- ✅ 嵌套作用域和变量遮蔽
- ✅ 综合测试
- ✅ 大量变量的重命名冲突
- ✅ 结构体成员保护
- ✅ 各种边界情况（操作符、注释、预处理、字符串、命名、类型、宏）

测试通过率: **14/14 (100%)**

## 性能考虑

- **解析开销**: tree-sitter解析器性能优秀，对于中等大小的文件（<10000行）几乎瞬时完成
- **内存使用**: AST会占用一定内存，但对于单个C文件来说完全可接受
- **重构效率**: 使用排序的修改列表，单次遍历即可完成重构

## 贡献指南

如果你想为本项目贡献代码：

1. Fork本仓库
2. 创建特性分支
3. 添加测试用例
4. 确保所有测试通过
5. 提交Pull Request

### 代码风格

- 遵循PEP 8
- 使用类型注解（推荐）
- 添加文档字符串
- 保持函数简洁

### 添加新测试

在 `tests/` 目录下创建新的 `.c` 文件，确保：
- 文件可以独立编译
- main函数返回0表示成功
- 测试覆盖特定的边界情况
